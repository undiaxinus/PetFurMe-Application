{"ast":null,"code":"import { Asset } from 'expo-asset';\nimport { CodedError } from 'expo-modules-core';\nimport ExpoFontLoader from './ExpoFontLoader';\nimport { FontDisplay } from './Font.types';\nfunction uriFromFontSource(asset) {\n  if (typeof asset === 'string') {\n    return asset || null;\n  } else if (typeof asset === 'number') {\n    return uriFromFontSource(Asset.fromModule(asset));\n  } else if (typeof asset === 'object' && typeof asset.uri === 'number') {\n    return uriFromFontSource(asset.uri);\n  } else if (typeof asset === 'object') {\n    return asset.uri || asset.localUri || asset.default || null;\n  }\n  return null;\n}\nfunction displayFromFontSource(asset) {\n  if (typeof asset === 'object' && 'display' in asset) {\n    return asset.display || FontDisplay.AUTO;\n  }\n  return FontDisplay.AUTO;\n}\nexport function getAssetForSource(source) {\n  const uri = uriFromFontSource(source);\n  const display = displayFromFontSource(source);\n  if (!uri || typeof uri !== 'string') {\n    throwInvalidSourceError(uri);\n  }\n  return {\n    uri,\n    display\n  };\n}\nfunction throwInvalidSourceError(source) {\n  let type = typeof source;\n  if (type === 'object') type = JSON.stringify(source, null, 2);\n  throw new CodedError(`ERR_FONT_SOURCE`, `Expected font asset of type \\`string | FontResource | Asset\\` instead got: ${type}`);\n}\nexport function loadSingleFontAsync(name, input) {\n  if (typeof input !== 'object' || typeof input.uri !== 'string' || input.downloadAsync) {\n    throwInvalidSourceError(input);\n  }\n  try {\n    return ExpoFontLoader.loadAsync(name, input);\n  } catch {}\n  return Promise.resolve();\n}","map":{"version":3,"names":["Asset","CodedError","ExpoFontLoader","FontDisplay","uriFromFontSource","asset","fromModule","uri","localUri","default","displayFromFontSource","display","AUTO","getAssetForSource","source","throwInvalidSourceError","type","JSON","stringify","loadSingleFontAsync","name","input","downloadAsync","loadAsync","Promise","resolve"],"sources":["D:\\XAMPP\\htdocs\\PetFurMe-Application\\node_modules\\expo-font\\src\\FontLoader.web.ts"],"sourcesContent":["import { Asset } from 'expo-asset';\nimport { CodedError } from 'expo-modules-core';\n\nimport ExpoFontLoader from './ExpoFontLoader';\nimport { FontResource, FontSource, FontDisplay } from './Font.types';\n\nfunction uriFromFontSource(asset: FontSource): string | number | null {\n  if (typeof asset === 'string') {\n    return asset || null;\n  } else if (typeof asset === 'number') {\n    return uriFromFontSource(Asset.fromModule(asset));\n  } else if (typeof asset === 'object' && typeof asset.uri === 'number') {\n    return uriFromFontSource(asset.uri);\n  } else if (typeof asset === 'object') {\n    return asset.uri || (asset as Asset).localUri || (asset as FontResource).default || null;\n  }\n\n  return null;\n}\n\nfunction displayFromFontSource(asset: FontSource): FontDisplay {\n  if (typeof asset === 'object' && 'display' in asset) {\n    return asset.display || FontDisplay.AUTO;\n  }\n\n  return FontDisplay.AUTO;\n}\n\nexport function getAssetForSource(source: FontSource): Asset | FontResource {\n  const uri = uriFromFontSource(source);\n  const display = displayFromFontSource(source);\n\n  if (!uri || typeof uri !== 'string') {\n    throwInvalidSourceError(uri);\n  }\n\n  return {\n    uri,\n    display,\n  };\n}\n\nfunction throwInvalidSourceError(source: any): never {\n  let type: string = typeof source;\n  if (type === 'object') type = JSON.stringify(source, null, 2);\n  throw new CodedError(\n    `ERR_FONT_SOURCE`,\n    `Expected font asset of type \\`string | FontResource | Asset\\` instead got: ${type}`\n  );\n}\n\n// NOTE(EvanBacon): No async keyword!\nexport function loadSingleFontAsync(name: string, input: Asset | FontResource): Promise<void> {\n  if (typeof input !== 'object' || typeof input.uri !== 'string' || (input as any).downloadAsync) {\n    throwInvalidSourceError(input);\n  }\n\n  try {\n    return ExpoFontLoader.loadAsync(name, input);\n  } catch {\n    // No-op.\n  }\n\n  return Promise.resolve();\n}\n"],"mappings":"AAAA,SAASA,KAAK,QAAQ,YAAY;AAClC,SAASC,UAAU,QAAQ,mBAAmB;AAE9C,OAAOC,cAAc,MAAM,kBAAkB;AAC7C,SAAmCC,WAAW,QAAQ,cAAc;AAEpE,SAASC,iBAAiBA,CAACC,KAAiB;EAC1C,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;IAC7B,OAAOA,KAAK,IAAI,IAAI;GACrB,MAAM,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;IACpC,OAAOD,iBAAiB,CAACJ,KAAK,CAACM,UAAU,CAACD,KAAK,CAAC,CAAC;GAClD,MAAM,IAAI,OAAOA,KAAK,KAAK,QAAQ,IAAI,OAAOA,KAAK,CAACE,GAAG,KAAK,QAAQ,EAAE;IACrE,OAAOH,iBAAiB,CAACC,KAAK,CAACE,GAAG,CAAC;GACpC,MAAM,IAAI,OAAOF,KAAK,KAAK,QAAQ,EAAE;IACpC,OAAOA,KAAK,CAACE,GAAG,IAAKF,KAAe,CAACG,QAAQ,IAAKH,KAAsB,CAACI,OAAO,IAAI,IAAI;;EAG1F,OAAO,IAAI;AACb;AAEA,SAASC,qBAAqBA,CAACL,KAAiB;EAC9C,IAAI,OAAOA,KAAK,KAAK,QAAQ,IAAI,SAAS,IAAIA,KAAK,EAAE;IACnD,OAAOA,KAAK,CAACM,OAAO,IAAIR,WAAW,CAACS,IAAI;;EAG1C,OAAOT,WAAW,CAACS,IAAI;AACzB;AAEA,OAAM,SAAUC,iBAAiBA,CAACC,MAAkB;EAClD,MAAMP,GAAG,GAAGH,iBAAiB,CAACU,MAAM,CAAC;EACrC,MAAMH,OAAO,GAAGD,qBAAqB,CAACI,MAAM,CAAC;EAE7C,IAAI,CAACP,GAAG,IAAI,OAAOA,GAAG,KAAK,QAAQ,EAAE;IACnCQ,uBAAuB,CAACR,GAAG,CAAC;;EAG9B,OAAO;IACLA,GAAG;IACHI;GACD;AACH;AAEA,SAASI,uBAAuBA,CAACD,MAAW;EAC1C,IAAIE,IAAI,GAAW,OAAOF,MAAM;EAChC,IAAIE,IAAI,KAAK,QAAQ,EAAEA,IAAI,GAAGC,IAAI,CAACC,SAAS,CAACJ,MAAM,EAAE,IAAI,EAAE,CAAC,CAAC;EAC7D,MAAM,IAAIb,UAAU,CAClB,iBAAiB,EACjB,8EAA8Ee,IAAI,EAAE,CACrF;AACH;AAGA,OAAM,SAAUG,mBAAmBA,CAACC,IAAY,EAAEC,KAA2B;EAC3E,IAAI,OAAOA,KAAK,KAAK,QAAQ,IAAI,OAAOA,KAAK,CAACd,GAAG,KAAK,QAAQ,IAAKc,KAAa,CAACC,aAAa,EAAE;IAC9FP,uBAAuB,CAACM,KAAK,CAAC;;EAGhC,IAAI;IACF,OAAOnB,cAAc,CAACqB,SAAS,CAACH,IAAI,EAAEC,KAAK,CAAC;GAC7C,CAAC,MAAM,C;EAIR,OAAOG,OAAO,CAACC,OAAO,EAAE;AAC1B","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}